
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	<span class="first-word">Spoiler</span> alert: Making a 2d physics engine
	is hard. After spending three days attempting to put together a "simple"
	ball bouncing engine, I am here, to declare my defeat. Calling it a defeat
	might be a little over dramatic. After all, I am a one-man team who desires
	perfection! And I am no creator of universes. I am the creator of bugs and
	lack-luster products: A software engineer.
</p>

<p>
	In this "tutorial", I hope to explain to you the do's and do-not's of
	starting your own physics engine by outlining all of the different
	thoughts, struggles, and need-to-knows before you take on a similar 
	endeavor.
</p>
<hr class="thickline">
<p>
	For me, this all started out after I shared my website on reddit. The 
	developer community I shared it with had nothing positive to say about
	the different mechanics I hand-built. And the biggest smack in the face
	was how people were telling me my website looked like a half-assed
	implementation of some template site.
	<span class="highlighter">
		I want my site to have a first great impression.  How can I accomplish 
		this?
	</span>
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->

<p>
	Before I started doing anything, I first asked myself what it was that a 
	good site must have to motivate the community to interact with it. I came
	up with the following list:
	<ol>
		<li>
			Content
		</li>
		<li>
			User Interactivity
		</li>
		<li>
			Design
		</li>
		<li>
			Readability and Organization
		</li>
	</ol>
	My site is readable, my site could be more organized, and the design is 
	blatantly simple. The content is going to take time, as building a large
	name blog does not happen over night. And the design is missing.
</p>

<p>
	Thus, I decided that I was going to make something that catches the eye.
	When someone lands on my site, I want them to feel like they found 
	something cool. If they learn something, sure, that is great, too. But
	sometimes the things we learn all like a little seed that just gets
	planted and will grow over time.
</p>
<p>
	<span class="highlighter">
		This seed being planted and fostering over time is exactly how I am 
		interpreting my experience with 2d physics engines.
	</span>
	Sure, I learned some more stuff about <code>reactjs</code>, but more
	importantly, I was able to really dust off my mathematics, physics,
	and alogrithm side of my brain. The nuts and bolts are why I got into
	software development, but I rarely am using them between writing
	<code>POST</code> and <code>GET</code> methods.
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	The overview of learned items while exploring 2d physics engines consist
	of:
	<span class="highlighter">
		<ol>
			<li>
				Keeping it simpler is always a good idea.
			</li>
			<li>
				Mathematics are the simpler method in the long run.
			</li>
			<li>
				Mathemtics and computers can get complex real fast.
			</li>
		</ol>
	</span>
	I found 
	<a href="https://www.myphysicslab.com/develop/docs/Engine2D.html">
		some great resources for learning about physics by Erik Newman
	</a>
	In a less abstract sense, the things that I learned are:
	<ol>
		<li>
			Momentum
		</li>
		<li>
			Gravity
		</li>
		<li>
			Inertia
		</li>
		<li>
			Velocity
		</li>
		<li>
			Impulse
		</li>
		<li>
			Matrices
		</li>
		<li>
			Rendering frames
		</li>
		<li>
			Angles, slopes, and distances
		</li>
		<li>
			Transfering of force
		</li>
		<li>
			Air resistance and drag
		</li>
	</ol>
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	I first took the time to learn <code>javascript</code> and <code>html
	</code> in terms of <code>Canvas</code>. The gist of learning these items 
	was pretty simple. I quickly was able to take the react tutorials that I 
	made live on my site and make a second rendering of the components that 
	let react live on my website. This consisted of copying the general
	template that I am using for this site and plugging a react div and id into
	the specified bootstrap container. I also had to declare a new an <code>
	CUSTOM_SCRIPT</code> of <code>ball_pen.js</code>.
</p>
<p>
	Once I had the div with id <code>ball-pen</code>, I went to work on the
	react file necessary to draw the ball-pen. This file was located in the same
	directory at <code>./src/ball_pen.js</code>. In my setup, I execute the
	following command to generate the javascript file from the react src code:
	<pre class="terminal-block">
		$&nbsp;<kbd class="bash-green">npx babel --watch src --out-dir . --presets react-app/prod </kbd>
	</pre>
	<!--See: https://reactjs.org/docs/add-react-to-a-website.html -->
	As the above JSX watcher runs in one terminal, I am writing code in another.
	As I save my changes, the JSX watcher will automatically update/generate 
	<code>./ball_pen.js</code> from the changes I make to 
	<code>./src/ball_pen.js</code>.
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	The ball-pen is our main point of <code>render</code> for this code. Thus,
	we put at the tail end of our file:
	<pre class="terminal-block">
		<kbd class="bash-green">
			&nbsp;ReactDOM.render(
			&nbsp;&nbsp;&nbsp;&nbsp;&lt;BallPen /&gt;,
			&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById('ball-pen')
			&nbsp;);
		</kbd>
	</pre>
	And we go on to declare the react component <code>BallPen</code> as:
	<pre class="terminal-block">
		<kbd class="bash-green">
			class BallPen extends React.Component{
			&nbsp;&nbsp;&nbsp;constructor(props){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(props);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.state&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= {
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height: 0,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:  0,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateWindowDimensions = this.updateWindowDimensions.bind(this);
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;componentDidMount() {
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateWindowDimensions();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateCanvas();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.timerID&nbsp;&nbsp;&nbsp;= setInterval(
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;()=&gt;this.updateCanvas(),
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.addEventListener('resize', this.updateWindowDimensions);
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;componentWillUnmount(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearInterval(this.timerID);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.removeEventListener('resize', this.updateWindowDimensions);
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;componentDidUpdate() {
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateCanvas();
			&nbsp;&nbsp;&nbsp;}
			
			&nbsp;&nbsp;&nbsp;updateWindowDimensions() {
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let width&nbsp;&nbsp;&nbsp;= window.innerWidth;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (width && width &gt;575)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width -= 320;&nbsp;&nbsp;&nbsp;//Buffer for not x-small
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width -= 120;&nbsp;&nbsp;&nbsp;//Buffer for x-small
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let height&nbsp;&nbsp;&nbsp;= window.innerHeight;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height&nbsp;&nbsp;&nbsp;-= 280;&nbsp;&nbsp;&nbsp;//Buffer...
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (height &lt; 0)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height = 0;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setState({
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width: width, 
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height: height
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;updateCanvas(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const canvas&nbsp;&nbsp;&nbsp;= this.canvasRef;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ctx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= canvas.getContext('2d');
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.beginPath();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.rect(0,0, this.state.width, this.state.height);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fillStyle = "#FF0000";
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fill();
			&nbsp;&nbsp;&nbsp;}
			
			&nbsp;&nbsp;&nbsp;render(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const penStyle&nbsp;&nbsp;&nbsp;= {
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;border:&nbsp;&nbsp;&nbsp;"1px solid #000000"
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;canvas
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ref={canvas =&gt; this.canvasRef = canvas}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width={this.state.width}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height={this.state.height}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style={penStyle}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&gt;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
			&nbsp;&nbsp;&nbsp;}
			}
		</kbd>
	</pre>
</p>
<p>
	The above code basically is using <code>states</code> and an <code>
	EventListener</code> to update the screen size if the window is changed.
	We put a couple of buffers in place for our current bootstrap container.
	And we modify those buffers for mobile versions, as well (x-small).
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	The other important thing that the above code is doing is adding a <code>
	setInterval</code> for when to perform an action. In our case, this action
	is going to be moving the ball. Once you have everything up and running, 
	your container should look something like:
</p>

<script type="text/babel" src="./../../../react/tests/ball-pen-1/ball_pen_1.js"></script>
<div id="ball-pen-1"></div>

<p>
	The first thing we need to do for moving the ball is first declaring a ball
	that we can move! In my case, I found that making a simple javascript class
	and using those components to then inact a draw on our canvas was the 
	easiest method. The reason for this choice was to make adding more balls
	onto the screen an easier case. This is my personal preference in coding
	style, as I like to have name classes and know what functions are working
	with what items just by the name space.  Thus, we will create our ball
	class at the head of our file:
	<pre class="terminal-block">
		<kbd class="bash-green">
			class&nbsp;Ball{
			&nbsp;&nbsp;&nbsp;constructor(properties){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.canvas&nbsp;&nbsp;=&nbsp;properties.canvas;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ballID&nbsp;&nbsp;=&nbsp;properties.ballID;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xCord&nbsp;&nbsp;&nbsp;=&nbsp;properties.xCord;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.yCord&nbsp;&nbsp;&nbsp;=&nbsp;properties.yCord;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.radius&nbsp;&nbsp;=&nbsp;properties.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;properties.dx;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;properties.dy;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.color&nbsp;&nbsp;&nbsp;=&nbsp;"blue";
			&nbsp;&nbsp;&nbsp;}//end constructor()
			&nbsp;&nbsp;&nbsp;draw(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ctx&nbsp;=&nbsp;this.canvas.getContext('2d');
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.beginPath();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.arc(
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xCord,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.yCord,&nbsp;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.radius,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2*Math.PI,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Start&nbsp;angle&nbsp;in&nbsp;radians
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//End&nbsp;angle&nbsp;in&nbsp;radians
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fillStyle&nbsp;=&nbsp;this.color;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fill();
			&nbsp;&nbsp;&nbsp;}//end draw()
			}//End&nbsp;Ball&nbsp;Class
		</kbd>
	</pre>
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->

<p>
	And once we are done making the `Ball` class, we can initialize it and 
	call draw on a `ball` within our `BallPen` class. The important things to
	note about the code above are the constructors and our first introduction
	to mathematics and physics in this whole thing: <code>this.dx</code> and 
	<code>this.dy</code>. If you have studied calculus, this should not be that
	foreign of a concept. The <code>d</code> representes <em>delta</em> and is
	often spoken as "the change in" something. So, reading <code>this.dx</code>
</p>
	is the equivalent of reading "the change in x for this ball". Here is the 
	code for making the <code>Ball</code> class:
		<pre class="terminal-block">
		<kbd class="bash-green">
			class&nbsp;BallPen&nbsp;extends&nbsp;React.Component{
			&nbsp;&nbsp;&nbsp;constructor(props){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(props);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.state&nbsp;=&nbsp;{
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;0,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;&nbsp;0,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.balls&nbsp;=&nbsp;[];
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
			&nbsp;&nbsp;&nbsp;}
			   
			&nbsp;&nbsp;&nbsp;updateCanvas(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;canvas&nbsp;&nbsp;&nbsp;=&nbsp;this.canvasRef;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ctx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;canvas.getContext('2d');
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.beginPath();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.rect(0,0,&nbsp;this.state.width,&nbsp;this.state.height);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fillStyle&nbsp;=&nbsp;"#FF0000";
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fill();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(this.state.width&nbsp;!==&nbsp;0){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(this.balls.length&nbsp;===&nbsp;0){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Init&nbsp;first&nbsp;ball    
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.balls.push(
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Ball({             
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;canvas:&nbsp;canvas,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ballID:&nbsp;0,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xCord:&nbsp;&nbsp;41,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yCord:&nbsp;&nbsp;41,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radius:&nbsp;30,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}//&nbsp;End&nbsp;first&nbsp;ball&nbsp;init;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(let&nbsp;i=0;&nbsp;i&lt;this.balls.length;&nbsp;i++){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;ball&nbsp;&nbsp;&nbsp;=&nbsp;this.balls[i];
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.draw();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}//end&nbsp;i-for
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

		</kbd>
	</pre>

</p>
<p>
	Once we have the ball drawn, our screen should look something like:
</p>

<script type="text/babel" src="./../../../react/tests/ball-pen-2/ball_pen_2.js"></script>
<div id="ball-pen-2"></div>

<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	Ta-da! We have successfully drawn a ball!	But just a ball being drawn
	is pretty boring, right? We could go ahead and add <code>gravity</code> to
	our balls, but what about things like <em>bounds</em>, <em>direction</em>,
	<em>air resistance</em>(aka <em>drag</em>), and <em>transfer of force</em>?
</p>
<p>
	That is a lot to cover, and if we start one component, it is very easy
	to get distracted and start the other component before we are done. In this
	tutorial, I want to have working example of interactions. Thus, let's start
	with <code>bounds</code> and then apply <code>gravity</code>. We will forgo
	the focus on stopping the ball for now, and instead make a ball that were
	bouncing as if in space with no friction and no transfering of force (we 
	will get to that later).
</p>
<p>
	We will declare four helper functions for the bounds:
	<ol>
		<li>
			<code>ball.hitTop()</code>
		</li>
		<li>
			<code>ball.hitBottom(maxHeight)</code>
		</li>
		<li>
			<code>ball.hitLeft()</code>
		</li>
		<li>
			<code>ball.hitRight(maxWidth)</code>
		</li>
	</ol>
	It is at this point, if you have not realized it yet, that we might need to
	change our thought process on how our <code>ball</code> is moving in 
	regards to <code>dx</code>, <code>dy</code>, and the <code>BallPen</code>.
	<span class="highlighter">
		The bottom right most coordinates are the largest values possible.
		When our slope is positive, the ball is in fact falling and going right.
	</span>
	If this is confusing, I would recommend taking the time and drawing a
	rectangle starting in the top-right at 0,0 and associating the other vertices
	to whatever size container you are using. From there, I would recommend 
	looking at lines and slopes (which make up <code>dx</code> and <code>dy
	</code>) from different points on this grid.
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	Back to the <code>bounds</code>, we will define them as such:
	<pre class="terminal-block">
		<kbd class="bash-green">
			class&nbsp;Ball{
			&nbsp;&nbsp;&nbsp;constructor(...){...}
			&nbsp;&nbsp;&nbsp;hitBottom(maxHeight){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ballMaxBottom&nbsp;=&nbsp;this.nextY&nbsp;+&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ballMaxBottom&nbsp;&gt;=&nbsp;maxHeight)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;
			&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;hitTop(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ballMaxTop&nbsp;=&nbsp;this.nextY&nbsp;-&nbsp;this.radius;    
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ballMaxTop&nbsp;&lt;=&nbsp;0)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;hitRight(maxWidth){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ballMaxRight&nbsp;=&nbsp;this.nextX&nbsp;+&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ballMaxRight&nbsp;&gt;=&nbsp;maxWidth)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;
			&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;hitLeft(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ballMaxLeft&nbsp;=&nbsp;this.nextX&nbsp;-&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ballMaxLeft&nbsp;&lt;=&nbsp;0)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;
			&nbsp;&nbsp;&nbsp;}//End Ball Class;
		</kbd>
	</pre>

</p>
<p>
	Next is to make a function that will handle the checks for the bounds and 
	make any changes within that scope that we will need it to. Let us call 
	this function <code>handleWallCollisions(maxWidth, maxHeight)</code>.
	This new function will properly pause the states if the container sizes
	are abused. And this function will change our directions as well as make
	sure that are planned updated coordinates stay within our container.
</p>
<p>
	Thus, this change brings about another change that we will need: <code>
	ball.nextX</code> and <code>ball.nextY</code>. Instead of just updating 
	the coordinates as we move along, we will say, "This is where we plan on
	moving. Are there any problems with this?" And if there are problems, 
	we update that frame before the problem ever existed. This change will take
	place within the <code>BallPen</code> and also be added as constructors
	for code clarity with the <code>Ball</code> class. Finally, our code 
	should look something like this:
	<pre class="terminal-block">
		<kbd class="bash-green">
			class&nbsp;Ball{
			&nbsp;&nbsp;&nbsp;constructor(...){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nextX&nbsp;&nbsp;&nbsp;=&nbsp;this.xCord&nbsp;+&nbsp;this.dx;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nextY&nbsp;&nbsp;&nbsp;=&nbsp;this.yCord&nbsp;+&nbsp;this.dy;
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;hitBottom(maxHeight){...}
			&nbsp;&nbsp;&nbsp;hitTop(){...}
			&nbsp;&nbsp;&nbsp;hitRight(maxWidth){...}
			&nbsp;&nbsp;&nbsp;hitLeft(){...}
			&nbsp;&nbsp;&nbsp;updateCoordinates(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xCord&nbsp;=&nbsp;this.nextX;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.yCord&nbsp;=&nbsp;this.nextY;
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;handleWallCollisions(maxWidth,&nbsp;maxHeight){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;willOverlapBottom&nbsp;=&nbsp;this.hitBottom(maxHeight);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;willOverlapTop&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;this.hitTop();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;willOverlapRight&nbsp;&nbsp;=&nbsp;this.hitRight(maxWidth);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;willOverlapLeft&nbsp;&nbsp;&nbsp;=&nbsp;this.hitLeft();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(willOverlapTop&nbsp;&&&nbsp;willOverlapBottom){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The&nbsp;screen&nbsp;is&nbsp;now&nbsp;to&nbsp;small&nbsp;for&nbsp;our&nbsp;ball;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//We&nbsp;will&nbsp;just&nbsp;keep&nbsp;the&nbsp;ball&nbsp;at&nbsp;it's&nbsp;current&nbsp;place&nbsp;and&nbsp;stop&nbsp;all&nbsp;movemnt;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nextX&nbsp;=&nbsp;this.xCord;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nextY&nbsp;=&nbsp;this.yCord;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dy&nbsp;=&nbsp;0;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dx&nbsp;=&nbsp;0;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('WARNING:&nbsp;SCREEN&nbsp;NOT&nbsp;FITTED;');
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(willOverlapBottom){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dy&nbsp;*=&nbsp;-1;&nbsp;&nbsp;&nbsp;//Change&nbsp;Direction
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nextY&nbsp;=&nbsp;maxHeight&nbsp;-&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(willOverlapTop){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dy&nbsp;*=&nbsp;-1;&nbsp;&nbsp;&nbsp;//Change&nbsp;Direction
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nextY&nbsp;=&nbsp;0&nbsp;+&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else{
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//No&nbsp;collision
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(willOverlapRight&nbsp;&&&nbsp;willOverlapLeft){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The&nbsp;screen&nbsp;is&nbsp;now&nbsp;to&nbsp;small&nbsp;for&nbsp;our&nbsp;ball;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//We&nbsp;will&nbsp;just&nbsp;keep&nbsp;the&nbsp;ball&nbsp;at&nbsp;it's&nbsp;current&nbsp;place&nbsp;and&nbsp;stop&nbsp;all&nbsp;movemnt;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nextX&nbsp;=&nbsp;this.xCord;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nextY&nbsp;=&nbsp;this.yCord;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dy&nbsp;=&nbsp;0;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dx&nbsp;=&nbsp;0;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('WARNING:&nbsp;SCREEN&nbsp;NOT&nbsp;FITTED;');
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(willOverlapRight){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dx&nbsp;*=&nbsp;-1;&nbsp;&nbsp;&nbsp;//Change&nbsp;Direction
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nextX&nbsp;=&nbsp;maxWidth&nbsp;-&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(willOverlapLeft){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dx&nbsp;*=&nbsp;-1;&nbsp;&nbsp;&nbsp;//Change&nbsp;Direction
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nextX&nbsp;=&nbsp;0&nbsp;+&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else{
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//No&nbsp;collision
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			
			&nbsp;&nbsp;&nbsp;}
			}//End&nbsp;Ball&nbsp;Class
			
			class&nbsp;BallPen&nbsp;extends&nbsp;React.Component{
			&nbsp;&nbsp;&nbsp;...
			&nbsp;&nbsp;&nbsp;updateCanvas(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(this.state.width&nbsp;!==&nbsp;0){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(let&nbsp;i=0;&nbsp;i&lt;this.balls.length;&nbsp;i++){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;ball&nbsp;&nbsp;&nbsp;=&nbsp;this.balls[i];
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.nextX&nbsp;=&nbsp;ball.xCord&nbsp;+&nbsp;ball.dx;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.nextY&nbsp;=&nbsp;ball.yCord&nbsp;+&nbsp;ball.dy;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.handleWallCollisions(this.state.width,&nbsp;this.state.height);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.updateCoordinates();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.draw();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}//end&nbsp;i-for
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;}//end&nbsp;updateCanvas()
			}
		</kbd>
	</pre>
</p>
<p>
	And finally, the "finished" product should looke like the following:
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<script type="text/babel" src="./../../../react/tests/ball-pen-3/ball_pen_3.js"></script>
<div id="ball-pen-3"></div>

<p>
	Next, let us define a very important property of are ball: <code>
	ball.isBouncing</code>. The next step we are going to take is a multistep
	process. In order to apply gravity, we also need to apply friction. And 
	as we go into the logic, we will want to put some other failsafes into
	place as our ball will now interact with the screen differently.
</p>
<p>
	This brings me to our first point, which is the wall interactions we just
	put in place. The code in <code>handleWallCollisions()</code> handles what
	happens when the ball is moving. It does not handle when the screen/window
	is being manipulated. Thus, our first change is within <code>
	updateWindowDimensions</code>. Append the following segment to the code:
	<pre class="terminal-block">
		<kbd class="bash-green">
			&nbsp;&nbsp;&nbsp;updateWindowDimensions(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(let&nbsp;i=0;&nbsp;i&lt;this.balls.length;&nbsp;i++){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;ball&nbsp;=&nbsp;this.balls[i];
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.handleWindowResize(width,&nbsp;height);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}//end&nbsp;i-for
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
			&nbsp;&nbsp;&nbsp;}//End&nbsp;updateWindowDimensions()
		</kbd>
	</pre>
	And then to define <code>Ball.handleWindowResize</code>:

	<pre class="terminal-block">
		<kbd class="bash-green">
			&nbsp;&nbsp;handleWindowResize(maxWidth,&nbsp;maxHeight){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ballBottom&nbsp;=&nbsp;this.yCord&nbsp;+&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ballTop&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;this.yCord&nbsp;-&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ballRight&nbsp;&nbsp;=&nbsp;this.xCord&nbsp;+&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ballLeft&nbsp;&nbsp;&nbsp;=&nbsp;this.xCord&nbsp;-&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ballBottom&nbsp;&gt;=&nbsp;height)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.yCord&nbsp;=&nbsp;height&nbsp;-&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ballTop&nbsp;&lt;=&nbsp;0)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.yCord&nbsp;=&nbsp;0&nbsp;+&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ballRight&nbsp;&gt;=&nbsp;width)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xCord&nbsp;=&nbsp;width&nbsp;-&nbsp;this.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ballLeft&nbsp;&lt;=&nbsp;0)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xCord&nbsp;=&nbsp;0&nbsp;+&nbsp;this.radius;
			&nbsp;&nbsp;}//end&nbsp;handleWindowResize()
		</kbd>
	</pre>
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	Once we have our window resizing taken care of, we can move onto applying
	<code>gravity</code> and <code>friction</code>. For right now, we will
	first setup just the friction applied by the container. Within the
	<code>BallPen</code> constructor add the property <code>friction</code>:
	<pre class="terminal-block">
		<kbd class="bash-green">
			class&nbsp;BallPen&nbsp;extends&nbsp;React.Component{
			&nbsp;&nbsp;&nbsp;constructor(props){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.friction&nbsp;=&nbsp;0.1;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateWindowDimensions&nbsp;=&nbsp;this.updateWindowDimensions.bind(this);
			&nbsp;&nbsp;&nbsp;}
		</kbd>
	</pre>
	Likewise, add <code>gravity</code> to the <code>Ball</code> constuctor.
	We are also going to now switch up the way we implemented <code>ball.dx
	</code>. We will now maintain an always positive value for the change in
	x and rather see if we are going to subtract or add that value to a ball's
	<code>nextX</code>. This property we will call <code>isGoingRight</code>.
	<pre class="terminal-block">
		<kbd class="bash-green">
			class&nbsp;Ball{
			&nbsp;&nbsp;&nbsp;constructor(properties){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.gravity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0.05;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.isGoingRight&nbsp;=&nbsp;true;
			&nbsp;&nbsp;&nbsp;}
		</kbd>
	</pre>
</p>
<p>
	The changes that <code>isGoingRight</code> will encompass <code>
	updateCanvas()</code> and <code>handleWallCollisions</code>. Within <code>
	updateCanvas</code> we will see this change on the larger update below. But
	within <code>handleWallCollisions</code>, we need to set a "true" or "false"
	values to the direction the ball is going when in contact with either the 
	left or right wall. Remove the <code>this.dx *= -1</code> and setup the
	boolean values as expected (yes, you can do this yourself).
</p>
<p>
	And now the fun part... Gravity! Let us make a <code>Ball.applyGravity()
	</code> method and <code>Ball.isBouncing()</code> method:
	<pre class="terminal-block">
		<kbd class="bash-green">applyGravity(){</kbd>
		<kbd class="bash-green">&nbsp;&nbsp;&nbsp;this.dy += this.gravity;</kbd>
		<kbd class="bash-green">}</kbd>
		<kbd class="bash-green">
			isBouncing(maxHeight, allBalls){
			&nbsp;&nbsp;&nbsp;if(this.hitBottom(maxHeight) && this.dy > 0){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Positive dy implies ball still wants to go down;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//If we are on the bottom, the ball can no longer go down;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;//TODO: For loop through allBalls
			&nbsp;&nbsp;&nbsp;return true;
			}
		</kbd>

	</pre>
	Okay, that wasn't that extreme. <em>C'est la programmin</em>. The <code>
	Ball.isBouncing()</code> method is also not that interesting, but the cool
	part is when it call comes together.
</p>
<p>
	Next is to practically rewrite how we implemented <code>updateCanvas</code>
	. We need to incorporate all of the changes up to this point:
	<ol>
		<li><code>
			friction
		</code></li>
		<li><code>
			gravity
		</code></li>
		<li><code>
			isGoingRight
		</code></li>
		<li><code>
			isBouncing
		</code></li>
	</ol>
	The updated <code>updateCanvas()</code> follows. Be sure to closely analyze
	the changes and <em>grok</em> the changes:

	<pre class="terminal-block">
		<kbd class="bash-green">
			updateCanvas(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;canvas&nbsp;&nbsp;&nbsp;=&nbsp;this.canvasRef;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ctx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;canvas.getContext('2d');
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.beginPath();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.rect(0,0,&nbsp;this.state.width,&nbsp;this.state.height);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fillStyle&nbsp;=&nbsp;"#FF0000";
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fill();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(this.state.width&nbsp;!==&nbsp;0){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(this.balls.length&nbsp;===&nbsp;0){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Init&nbsp;first&nbsp;ball
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.balls.push(
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Ball({
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;canvas:&nbsp;&nbsp;&nbsp;canvas,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ballID:&nbsp;&nbsp;&nbsp;0,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xCord:&nbsp;&nbsp;&nbsp;41,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yCord:&nbsp;&nbsp;&nbsp;41,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radius:&nbsp;&nbsp;&nbsp;30,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}//&nbsp;End&nbsp;first&nbsp;ball&nbsp;init;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(let&nbsp;i=0;&nbsp;i&lt;this.balls.length;&nbsp;i++){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;ball&nbsp;&nbsp;&nbsp;=&nbsp;this.balls[i];
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;isBouncing&nbsp;&nbsp;&nbsp;=&nbsp;ball.isBouncing(this.state.height,&nbsp;this.balls);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;!isBouncing&nbsp;&&&nbsp;ball.dx&nbsp;===&nbsp;0){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Ball&nbsp;is&nbsp;static;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.draw();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.font&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;"15px&nbsp;Arial";
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fillStyle&nbsp;=&nbsp;"white";
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fillText("Static",&nbsp;ball.xCord-ball.radius+1,&nbsp;ball.yCord+1);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(&nbsp;!isBouncing){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ball.isGoingRight)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.nextX&nbsp;=&nbsp;ball.xCord&nbsp;+&nbsp;ball.dx;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.nextX&nbsp;=&nbsp;ball.xCord&nbsp;-&nbsp;ball.dx;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Ball&nbsp;is&nbsp;rolling;&nbsp;Apply&nbsp;friction;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.dx&nbsp;-=&nbsp;this.friction;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ball.dx&nbsp;&lt;&nbsp;0)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.dx&nbsp;=&nbsp;0;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else{
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.applyGravity();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.nextY&nbsp;=&nbsp;ball.yCord&nbsp;+&nbsp;ball.dy;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ball.isGoingRight)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.nextX&nbsp;=&nbsp;ball.xCord&nbsp;+&nbsp;ball.dx;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.nextX&nbsp;=&nbsp;ball.xCord&nbsp;-&nbsp;ball.dx;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.handleWallCollisions(this.state.width,&nbsp;this.state.height,&nbsp;this.friction);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.updateCoordinates();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.draw();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}//end&nbsp;i-for
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;}
		</kbd>
	</pre>
</p>
<p>
	And the finaly product should looke something like:
</p>
<script type="text/babel" src="./../../../react/tests/ball-pen-4/ball_pen_4.js"></script>
<div id="ball-pen-4"></div>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	Unfortunately, this is the point where the coding comes to a close. For us
	to go any further, we have to go into radians, angles, velocity, vectors, 
	and more. We could easily rewrite our code to econpmass these things,
	however, after my own experimenting with it has lead me to believe that
	even incorporating these features will not fully fix the bugs that are
	present. As soon as we apply gravity and try to stack balls ontop of 
	eachother, the layer of  confusion in the code piles up, which is evident
	within the balls on the screen. That is why professional physics engines
	use a certain number of sides for circles instead of calculating the cirle
	as it's own entity.
</p>
<p>
</p>
<p>
	<pre class="terminal-block">
		$&nbsp;<kbd class="bash-green">passtow</kbd>
		$&nbsp;<kbd class="bash-green">cd public_html</kbd>
		$&nbsp;<kbd class="bash-green">git pull</kbd>
	</pre>
</p>
