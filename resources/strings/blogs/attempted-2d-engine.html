
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	<span class="first-word">Spoiler</span> alert: Making a 2d physics engine
	is hard. After spending three days attempting to put together a "simple"
	ball bouncing engine, I am here, to declare my defeat. Calling it a defeat
	might be a little over dramatic. After all, I am a one-man team who desires
	perfection! And I am no creator of universes. I am the creator of bugs and
	lack-luster products: A software engineer.
</p>

<p>
	In this "tutorial", I hope to explain to you the do's and do-not's of
	starting your own physics engine by outlining all of the different
	thoughts, struggles, and need-to-knows before you take on a similar 
	endeavor.
</p>
<hr class="thickline">
<p>
	For me, this all started out after I shared my website on reddit. The 
	developer community I shared it with had nothing positive to say about
	the different mechanics I hand-built. And the biggest smack in the face
	was how people were telling me my website looked like a half-assed
	implementation of some template site.
	<span class="highlighter">
		I want my site to have a first great impression.  How can I accomplish 
		this?
	</span>
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->

<p>
	Before I started doing anything, I first asked myself what it was that a 
	good site must have to motivate the community to interact with it. I came
	up with the following list:
	<ol>
		<li>
			Content
		</li>
		<li>
			User Interactivity
		</li>
		<li>
			Design
		</li>
		<li>
			Readability and Organization
		</li>
	</ol>
	My site is readable, my site could be more organized, and the design is 
	blatantly simple. The content is going to take time, as building a large
	name blog does not happen over night. And the design is missing.
</p>

<p>
	Thus, I decided that I was going to make something that catches the eye.
	When someone lands on my site, I want them to feel like they found 
	something cool. If they learn something, sure, that is great, too. But
	sometimes the things we learn all like a little seed that just gets
	planted and will grow over time.
</p>
<p>
	<span class="highlighter">
		This seed being planted and fostering over time is exactly how I am 
		interpreting my experience with 2d physics engines.
	</span>
	Sure, I learned some more stuff about <code>reactjs</code>, but more
	importantly, I was able to really dust off my mathematics, physics,
	and alogrithm side of my brain. The nuts and bolts are why I got into
	software development, but I rarely am using them between writing
	<code>POST</code> and <code>GET</code> methods.
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	The overview of learned items while exploring 2d physics engines consist
	of:
	<span class="highlighter">
		<ol>
			<li>
				Keeping it simpler is always a good idea.
			</li>
			<li>
				Mathematics are the simpler method in the long run.
			</li>
			<li>
				Mathemtics and computers can get complex real fast.
			</li>
		</ol>
	</span>
	I found 
	<a href="https://www.myphysicslab.com/develop/docs/Engine2D.html">
		some great resources for learning about physics by Erik Newman
	</a>
	In a less abstract sense, the things that I learned are:
	<ol>
		<li>
			Momentum
		</li>
		<li>
			Gravity
		</li>
		<li>
			Inertia
		</li>
		<li>
			Velocity
		</li>
		<li>
			Impulse
		</li>
		<li>
			Matrices
		</li>
		<li>
			Rendering frames
		</li>
		<li>
			Angles, slopes, and distances
		</li>
		<li>
			Transfering of force
		</li>
		<li>
			Air resistance and drag
		</li>
	</ol>
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	I first took the time to learn <code>javascript</code> and <code>html
	</code> in terms of <code>Canvas</code>. The gist of learning these items 
	was pretty simple. I quickly was able to take the react tutorials that I 
	made live on my site and make a second rendering of the components that 
	let react live on my website. This consisted of copying the general
	template that I am using for this site and plugging a react div and id into
	the specified bootstrap container. I also had to declare a new an <code>
	CUSTOM_SCRIPT</code> of <code>ball_pen.js</code>.
</p>
<p>
	Once I had the div with id <code>ball-pen</code>, I went to work on the
	react file necessary to draw the ball-pen. This file was located in the same
	directory at <code>./src/ball_pen.js</code>. In my setup, I execute the
	following command to generate the javascript file from the react src code:
	<pre class="terminal-block">
		$&nbsp;<kbd class="bash-green">npx babel --watch src --out-dir . --presets react-app/prod </kbd>
	</pre>
	<!--See: https://reactjs.org/docs/add-react-to-a-website.html -->
	As the above JSX watcher runs in one terminal, I am writing code in another.
	As I save my changes, the JSX watcher will automatically update/generate 
	<code>./ball_pen.js</code> from the changes I make to 
	<code>./src/ball_pen.js</code>.
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	The ball-pen is our main point of <code>render</code> for this code. Thus,
	we put at the tail end of our file:
	<pre class="terminal-block">
		<kbd class="bash-green">
			&nbsp;ReactDOM.render(
			&nbsp;&nbsp;&nbsp;&nbsp;&lt;BallPen /&gt;,
			&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById('ball-pen')
			&nbsp;);
		</kbd>
	</pre>
	And we go on to declare the react component <code>BallPen</code> as:
	<pre class="terminal-block">
		<kbd class="bash-green">
			class BallPen extends React.Component{
			&nbsp;&nbsp;&nbsp;constructor(props){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(props);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.state&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= {
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height: 0,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:  0,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateWindowDimensions = this.updateWindowDimensions.bind(this);
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;componentDidMount() {
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateWindowDimensions();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateCanvas();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.timerID&nbsp;&nbsp;&nbsp;= setInterval(
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;()=&gt;this.updateCanvas(),
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.addEventListener('resize', this.updateWindowDimensions);
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;componentWillUnmount(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearInterval(this.timerID);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.removeEventListener('resize', this.updateWindowDimensions);
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;componentDidUpdate() {
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.updateCanvas();
			&nbsp;&nbsp;&nbsp;}
			
			&nbsp;&nbsp;&nbsp;updateWindowDimensions() {
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let width&nbsp;&nbsp;&nbsp;= window.innerWidth;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (width && width &gt;575)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width -= 320;&nbsp;&nbsp;&nbsp;//Buffer for not x-small
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width -= 120;&nbsp;&nbsp;&nbsp;//Buffer for x-small
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let height&nbsp;&nbsp;&nbsp;= window.innerHeight;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height&nbsp;&nbsp;&nbsp;-= 280;&nbsp;&nbsp;&nbsp;//Buffer...
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (height &lt; 0)
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height = 0;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setState({
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width: width, 
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height: height
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
			&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;updateCanvas(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const canvas&nbsp;&nbsp;&nbsp;= this.canvasRef;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ctx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= canvas.getContext('2d');
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.beginPath();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.rect(0,0, this.state.width, this.state.height);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fillStyle = "#FF0000";
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fill();
			&nbsp;&nbsp;&nbsp;}
			
			&nbsp;&nbsp;&nbsp;render(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const penStyle&nbsp;&nbsp;&nbsp;= {
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;border:&nbsp;&nbsp;&nbsp;"1px solid #000000"
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;canvas
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ref={canvas =&gt; this.canvasRef = canvas}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width={this.state.width}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height={this.state.height}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style={penStyle}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&gt;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
			&nbsp;&nbsp;&nbsp;}
			}
		</kbd>
	</pre>
</p>
<p>
	The above code basically is using <code>states</code> and an <code>
	EventListener</code> to update the screen size if the window is changed.
	We put a couple of buffers in place for our current bootstrap container.
	And we modify those buffers for mobile versions, as well (x-small).
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	The other important thing that the above code is doing is adding a <code>
	setInterval</code> for when to perform an action. In our case, this action
	is going to be moving the ball. Once you have everything up and running, 
	your container should look something like:
</p>

<script type="text/babel" src="./../../../react/tests/ball-pen-1/ball_pen_1.js"></script>
<div id="ball-pen-1"></div>

<p>
	The first thing we need to do for moving the ball is first declaring a ball
	that we can move! In my case, I found that making a simple javascript class
	and using those components to then inact a draw on our canvas was the 
	easiest method. The reason for this choice was to make adding more balls
	onto the screen an easier case. This is my personal preference in coding
	style, as I like to have name classes and know what functions are working
	with what items just by the name space.  Thus, we will create our ball
	class at the head of our file:
	<pre class="terminal-block">
		<kbd class="bash-green">
			class&nbsp;Ball{
			&nbsp;&nbsp;&nbsp;constructor(properties){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.canvas&nbsp;&nbsp;=&nbsp;properties.canvas;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ballId&nbsp;&nbsp;=&nbsp;properties.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xCord&nbsp;&nbsp;&nbsp;=&nbsp;properties.xCord;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.yCord&nbsp;&nbsp;&nbsp;=&nbsp;properties.yCord;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.radius&nbsp;&nbsp;=&nbsp;properties.radius;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;properties.dx;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;properties.dy;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.color&nbsp;&nbsp;&nbsp;=&nbsp;"blue";
			&nbsp;&nbsp;&nbsp;}//end constructor()
			&nbsp;&nbsp;&nbsp;draw(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ctx&nbsp;=&nbsp;this.canvas.getContext('2d');
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.beginPath();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.arc(
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.xCord,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.yCord,&nbsp;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.radius,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2*Math.PI,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Start&nbsp;angle&nbsp;in&nbsp;radians
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//End&nbsp;angle&nbsp;in&nbsp;radians
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fillStyle&nbsp;=&nbsp;this.color;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fill();
			&nbsp;&nbsp;&nbsp;}//end draw()
			}//End&nbsp;Ball&nbsp;Class
		</kbd>
	</pre>
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->

<p>
	And once we are done making the `Ball` class, we can initialize it and 
	call draw on a `ball` within our `BallPen` class. The important things to
	note about the code above are the constructors and our first introduction
	to mathematics and physics in this whole thing: <code>this.dx</code> and 
	<code>this.dy</code>. If you have studied calculus, this should not be that
	foreign of a concept. The <code>d</code> representes <em>delta</em> and is
	often spoken as "the change in" something. So, reading <code>this.dx</code>
</p>
	is the equivalent of reading "the change in x for this ball". Here is the 
	code for making the <code>Ball</code> class:
		<pre class="terminal-block">
		<kbd class="bash-green">
			class&nbsp;BallPen&nbsp;extends&nbsp;React.Component{
			&nbsp;&nbsp;&nbsp;constructor(props){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(props);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.state&nbsp;=&nbsp;{
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;0,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;&nbsp;0,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.balls&nbsp;=&nbsp;[];
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
			&nbsp;&nbsp;&nbsp;}
			   
			&nbsp;&nbsp;&nbsp;updateCanvas(){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;canvas&nbsp;&nbsp;&nbsp;=&nbsp;this.canvasRef;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ctx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;canvas.getContext('2d');
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.beginPath();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.rect(0,0,&nbsp;this.state.width,&nbsp;this.state.height);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fillStyle&nbsp;=&nbsp;"#FF0000";
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fill();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(this.state.width&nbsp;!==&nbsp;0){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(this.balls.length&nbsp;===&nbsp;0){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Init&nbsp;first&nbsp;ball    
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.balls.push(
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Ball({             
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;canvas:&nbsp;canvas,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ballId:&nbsp;0,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xCord:&nbsp;&nbsp;41,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yCord:&nbsp;&nbsp;41,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radius:&nbsp;30,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2,
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}//&nbsp;End&nbsp;first&nbsp;ball&nbsp;init;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(let&nbsp;i=0;&nbsp;i&lt;this.balls.length;&nbsp;i++){
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;ball&nbsp;&nbsp;&nbsp;=&nbsp;this.balls[i];
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ball.draw();
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}//end&nbsp;i-for
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

		</kbd>
	</pre>

</p>
<p>
	Once we have the ball drawn, our screen should look something like:
</p>

<script type="text/babel" src="./../../../react/tests/ball-pen-2/ball_pen_2.js"></script>
<div id="ball-pen-2"></div>

<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	Ta-da! We have successfully drawn a ball!	But just a ball being drawn
	is pretty boring, right? We could go ahead and add <code>gravity</code> to
	our balls, but what about things like <em>bounds</em>, <em>direction</em>,
	<em>air resistance</em>(aka <em>drag</em>), and <em>transfer of force</em>?
</p>
<p>
	That is a lot to cover, and if we start one component, it is very easy
	to get distracted and start the other component before we are done. In this
	tutorial, I want to have working example of interactions. Thus, let's start
	with <code>bounds</code> and then apply <code>gravity</code>. We will forgo
	the focus on stopping the ball for now, and instead make a ball that were
	bouncing as if in space with no friction and no transfering of force (we 
	will get to that later).
</p>
<p>
	We will declare four helper functions for the bounds:
	<ol>
		<li>
			<code>ball.hitTop()</code>
		</li>
		<li>
			<code>ball.hitBottom(maxHeight)</code>
		</li>
		<li>
			<code>ball.hitLeft()</code>
		</li>
		<li>
			<code>ball.hitRight(maxWidth)</code>
		</li>
	</ol>
	It is at this point, if you have not realized it yet, that we might need to
	change our thought process on how our <code>ball</code> is moving in 
	regards to <code>dx</code>, <code>dy</code>, and the <code>BallPen</code>.
	<span class="highlighter">
		The bottom right most coordinates are the largest values possible.
		When our slope is positive, the ball is in fact falling and going right.
	</span>
	If this is confusing, I would recommend taking the time out and drawing a
	rectangle starting in the top-right at 0,0 and associating the other points
	to whatever size container you are using. From there, I would recommend 
	looking at lines and slopes (which make up <code>dx</code> and <code>dy
	</code>) from different points on this grid.
</p>
<!---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---->
<p>
	Back to the <code>bounds</code>, we will define them as such:
	<pre class="terminal-block">
		<kbd class="bash-green">
		
		</kbd>
	</pre>

</p>

<script type="text/babel" src="./../../../react/tests/ball-pen-3/ball_pen_3.js"></script>
<div id="ball-pen-3"></div>

<p>
	
</p>
<p>
	<pre class="terminal-block">
		$&nbsp;<kbd class="bash-green">passtow</kbd>
		$&nbsp;<kbd class="bash-green">cd public_html</kbd>
		$&nbsp;<kbd class="bash-green">git pull</kbd>
	</pre>
</p>
