{"version":3,"sources":["logo.svg","serviceWorker.js","Ball.js","BallPen.jsx","index.js"],"names":["module","exports","Boolean","window","location","hostname","match","Ball","properties","this","canvas","ballID","xCord","yCord","radius","dx","dy","color","nextX","nextY","ctx","getContext","beginPath","arc","Math","PI","fillStyle","fill","maxWidth","maxHeight","willOverlapBottom","hitBottom","willOverlapTop","hitTop","willOverlapRight","hitRight","willOverlapLeft","hitLeft","console","log","BallPen","props","state","height","width","balls","updateWindowDimensions","bind","updateCanvas","timerID","setInterval","addEventListener","clearInterval","removeEventListener","innerWidth","innerHeight","setState","canvasRef","rect","length","push","i","ball","handleWallCollisions","updateCoordinates","draw","ref","style","border","React","Component","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.146f98f6.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","'use strict';\nexport class Ball{\n\tconstructor(properties){\n\t\tthis.canvas\t= properties.canvas;\n\t\tthis.ballID\t= properties.ballID;\n\t\tthis.xCord\t= properties.xCord;\n\t\tthis.yCord\t= properties.yCord;\n\t\tthis.radius\t= properties.radius;\n\t\tthis.dx \t\t= properties.dx;\n\t\tthis.dy\t\t= properties.dy;\n\t\tthis.color\t= \"blue\";\n\t\tthis.nextX\t= this.xCord + this.dx;\n\t\tthis.nextY\t= this.yCord + this.dy;\n\t}\n\tdraw(){\n\t\tconst ctx = this.canvas.getContext('2d');\n\t\tctx.beginPath();\n\t\tctx.arc(\n\t\t\tthis.xCord,\n\t\t\tthis.yCord, \n\t\t\tthis.radius,\n\t\t\t2*Math.PI,\t\t//Start angle in radians\n\t\t\t0\t\t\t\t\t//End angle in radians\n\t\t);\n\t\tctx.fillStyle = this.color;\n\t\tctx.fill();\n\t}\n\tupdateCoordinates(){\n\t\tthis.xCord = this.nextX;\n\t\tthis.yCord = this.nextY;\n\t}\n\thandleWallCollisions(maxWidth, maxHeight){\n\t\tconst willOverlapBottom\t= this.hitBottom(maxHeight);\n\t\tconst willOverlapTop\t\t= this.hitTop();\n\t\tconst willOverlapRight\t= this.hitRight(maxWidth);\n\t\tconst willOverlapLeft\t= this.hitLeft();\n\t\tif(willOverlapTop && willOverlapBottom){\n\t\t\t//The screen is now to small for our ball;\n\t\t\t//We will just keep the ball at it's current place and stop all movemnt;\n\t\t\tthis.nextX = this.xCord;\n\t\t\tthis.nextY = this.yCord;\n\t\t\tthis.dy = 0;\n\t\t\tthis.dx = 0;\n\t\t\tconsole.log('WARNING: SCREEN NOT FITTED;');\n\t\t}\n\t\telse if(willOverlapBottom){\n\t\t\tthis.dy *= -1;\n\t\t\tthis.nextY = maxHeight - this.radius;\n\t\t}\n\t\telse if(willOverlapTop){\n\t\t\tthis.dy *= -1;\n\t\t\tthis.nextY = 0 + this.radius;\n\t\t}\n\t\telse{\n\t\t\t//No collision\n\t\t}\n\t\tif(willOverlapRight && willOverlapLeft){\n\t\t\t//The screen is now to small for our ball;\n\t\t\t//We will just keep the ball at it's current place and stop all movemnt;\n\t\t\tthis.nextX = this.xCord;\n\t\t\tthis.nextY = this.yCord;\n\t\t\tthis.dy = 0;\n\t\t\tthis.dx = 0;\n\t\t\tconsole.log('WARNING: SCREEN NOT FITTED;');\n\t\t}\n\t\telse if(willOverlapRight){\n\t\t\tthis.dx *= -1;\n\t\t\tthis.nextX = maxWidth - this.radius;\n\t\t}\n\t\telse if(willOverlapLeft){\n\t\t\tthis.dx *= -1;\n\t\t\tthis.nextX = 0 + this.radius;\n\t\t}\n\t\telse{\n\t\t\t//No collision\n\t\t}\n\n\t}\n\thitBottom(maxHeight){\n\t\tconst ballMaxBottom = this.nextY + this.radius;\n\t\tif(ballMaxBottom >= maxHeight)\n\t\t\treturn true;\n\t\treturn false;\n\t\n\t}\n\thitTop(){\n\t\tconst ballMaxTop = this.nextY - this.radius;\n\t\tif(ballMaxTop <= 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\thitRight(maxWidth){\n\t\tconst ballMaxRight = this.nextX + this.radius;\n\t\tif(ballMaxRight >= maxWidth)\n\t\t\treturn true;\n\t\treturn false;\n\t\n\t}\n\thitLeft(){\n\t\tconst ballMaxLeft = this.nextX - this.radius;\n\t\tif(ballMaxLeft <= 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}//End Ball Class\n","import React, { Component } from \"react\";\nimport { Ball } from \"./Ball.js\";\n\nclass BallPen extends React.Component{\n   constructor(props){\n      super(props);\n      this.state      = {\n         height: 0,\n         width:  0,\n      };\n\t\tthis.balls\t= [];\n      this.updateWindowDimensions = this.updateWindowDimensions.bind(this);\n   }\n   \n   componentDidMount() {\n      this.updateWindowDimensions();\n      this.updateCanvas();\n      this.timerID   = setInterval(\n         ()=>this.updateCanvas(),\n         25\n      );\n      window.addEventListener('resize', this.updateWindowDimensions);\n   }\n   componentWillUnmount(){\n      clearInterval(this.timerID);\n      window.removeEventListener('resize', this.updateWindowDimensions);\n   }\n   componentDidUpdate() {\n      this.updateCanvas();\n   }\n\n   updateWindowDimensions() {\n      let width   = window.innerWidth;\n      if (width && width >575)\n         width -= 320;   //Buffer for not x-small\n      else\n         width -= 120;   //Buffer for x-small\n      let height   = window.innerHeight;\n      height   -= 280;   //Buffer...\n      if (height < 0)\n         height = 0;\n      this.setState({\n         width: width, \n         height: height\n      });\n      return;\n   }\n   updateCanvas(){\n      const canvas   = this.canvasRef;\n      const ctx      = canvas.getContext('2d');\n      ctx.beginPath();\n      ctx.rect(0,0, this.state.width, this.state.height);\n      ctx.fillStyle = \"#FF0000\";\n      ctx.fill();\n\t\tif(this.state.width !== 0){\n\t\t\tif(this.balls.length === 0){\n\t\t\t\t// Init first ball\n\t\t\t\tthis.balls.push(\n\t\t\t\t\tnew Ball({\n\t\t\t\t\t\tcanvas:\tcanvas,\n\t\t\t\t\t\tballID:\t0,\n\t\t\t\t\t\txCord:\t41,\n\t\t\t\t\t\tyCord:\t41,\n\t\t\t\t\t\tradius:\t30,\n\t\t\t\t\t\tdx: \t\t2,\n\t\t\t\t\t\tdy:\t\t2\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}// End first ball init;\n\t\t\tfor(let i=0; i<this.balls.length; i++){\n\t\t\t\tlet ball\t= this.balls[i];\n\t\t\t\tball.nextX = ball.xCord + ball.dx;\n\t\t\t\tball.nextY = ball.yCord + ball.dy;\n\t\t\t\tball.handleWallCollisions(this.state.width, this.state.height);\n\t\t\t\tball.updateCoordinates();\n\t\t\t\tball.draw();\n\t\t\t}//end i-for\n\t\t}\n   }\n\n   render(){\n      const penStyle   = {\n         border:   \"1px solid #000000\"\n      };\n      return (\n         <div>\n            <canvas\n               ref={canvas => this.canvasRef = canvas}\n               width={this.state.width}\n               height={this.state.height}\n               style={penStyle}\n            />\n         </div>\n      );\n   }\n}\nexport default BallPen;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport BallPen from \"./BallPen\";\n\nReactDOM.render(<BallPen />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}